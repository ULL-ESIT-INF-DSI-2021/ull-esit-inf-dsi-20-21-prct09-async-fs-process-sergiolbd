{"version":3,"file":"/home/sergio/Documentos/3º Info/2º Cuatri/DSI/mod2/src/TemplateMethod.ts","sources":["/home/sergio/Documentos/3º Info/2º Cuatri/DSI/mod2/src/TemplateMethod.ts"],"names":[],"mappings":";AAAA;;;;;;;;GAQG;;;AAGH,MAAsB,MAAM;IAE1B,YAAsB,UAAoB;QAApB,eAAU,GAAV,UAAU,CAAU;IAE1C,CAAC;IAEM,GAAG;QACR,IAAI,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;QAElB,IAAI,CAAC,cAAc,EAAE,CAAC;IACxB,CAAC;IAED,SAAS;QACP,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED,QAAQ;QACN,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAED,SAAS,CAAC,OAAe;QACvB,IAAI,MAAM,GAAG,OAAO,KAAK,SAAS,CAAC,CAAC,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;QAElE,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAC/C,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC;SAC/C;QACD,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,OAAO,MAAM,CAAC;IAChB,CAAC;CAMF;AAlCD,wBAkCC;AAED,MAAa,SAAU,SAAQ,MAAM;IACnC,YAAsB,UAAoB;QACxC,KAAK,CAAC,UAAU,CAAC,CAAC;QADE,eAAU,GAAV,UAAU,CAAU;IAE1C,CAAC;IAED,GAAG,CAAC,CAAS,EAAE,CAAQ;QACrB,OAAO,CAAC,GAAC,CAAC,CAAC;IACb,CAAC;IAED,uCAAuC;IACvC,uEAAuE;IAEvE,uDAAuD;IACvD,qDAAqD;IACrD,MAAM;IACN,0BAA0B;IAC1B,mBAAmB;IACnB,IAAI;IAEJ,cAAc;QACZ,OAAO,iBAAiB,CAAC;IAC3B,CAAC;CACF;AAtBD,8BAsBC","sourcesContent":["/**\n * Patrón Template Method (Comportamiento)\n * Permite definir un esqueleto algorítmico en una superclase, de modo que\n * aquellas subclases que extiendan el comportamiento de dicho esqueleto puedan\n * sobreescribir algunos pasos del algorítmo sin modificar su estructura base\n * \n * Ventajas --> Respeta Open-closed\n * Destentajas --> No respeta Liskov Substitution\n */\n\n\nexport abstract class Reduce {\n  protected result: number;\n  constructor(protected inputArray: number[]) {\n\n  }\n\n  public run() {\n    this.addReduce(0);\n\n    this.afterAddReduce();\n  }\n\n  getResult() {\n    return this.result;\n  }\n\n  getArray() {\n    return this.inputArray;\n  }\n\n  addReduce(inicial: number): number {\n    let result = inicial !== undefined ? inicial : this.inputArray[0];\n\n    for (let i = 0; i < this.inputArray.length; i++) {\n      result = this.add(result, this.inputArray[i]);\n    }\n    this.result = result;\n    return result;\n  }\n\n  abstract afterAddReduce(): string;\n\n  // abstract addReduce(incial: number): number;\n  abstract add(a: number, b:number): number;\n}\n\nexport class AddReduce extends Reduce {\n  constructor(protected inputArray: number[]) {\n    super(inputArray);\n  }\n\n  add(a: number, b:number) {\n    return a+b;\n  }\n\n  // addReduce(inicial: number): number {\n  //   let result = inicial !== undefined ? inicial : this.inputArray[0];\n\n  //   for (let i = 0; i < this.inputArray.length; i++) {\n  //     result = this.add(result, this.inputArray[i]);\n  //   }\n  //   this.result = result;\n  //   return result;\n  // }\n\n  afterAddReduce() {\n    return 'Vector reducido';\n  }\n}\n\n\n"]}